# RDBMS?

- 테이블 속성

  - 열 : 컬럼, 필드, 속성
    - 컬럼마다 데이터형 준다.
  - 행 : 튜플, 레코드
    - 열과 행으로 이루어져있으므로 2차원이고, 이게 관계형 데이터베이스

- 주 식별자(Primary Key)

  - 1 홍길동 서울시 34
  - 2 김홍도 경기도 24
  - 3 황진이 부산시 27
    - 1이 PK
    - 하나의 레코드를 고유하게 구분할 수 있는 것으로 하나의 컬럼 또는 여러개의 컬럼이 모여 PK를 구성
    - NotNull & Unique
      - 주 식별자
      - NotNull을 무조건 만족해야 주 식별자다.
    - 후보 식별자
      - null을 인정
      - 식별자는 무조건 unique
      - 핸드폰의 경우 unique지만 없을 수도 있으므로 null이 가능.
    - 테이블 등록시 명시해주어야함
    - PK가 없다면 중복된 값이 있을 수 있으므로, 데이터를 삭제하거나 수정할 때 중복된 갑을 삭제하거나 수정할 수 있으므로 큰일난다.

- 키

  - 하나의 테이블에서 각 레코드를 고유하게 식별할 수 있는 컬럼 또는 컬럼의 조합
  - 테이블 디자인 시 키를 정하고 테이블을 데이터베이스에 만들 때 명시적으로 키를 선언
  - 키는 키에 대응하는 인덱스 테이블이 생성됨
    - 인덱스 테이블은 키 값에 의해서 정렬되어 있음.
      - 정렬되어있으므로 빨리 찾을 수 있음.
  - 결정자
    - PK
  - 나머지는 종속자
  - 우리가 부여한 고객번호가 PK가 되면 좋다.
    - 우리가 그 로직을 갖고 있으므로.
  - 관계형데이터베이스가 되기 위해선 반드시 PK가 포함되어야한다.

- 데이터 타입

  - 정수
    - Bit
    - Int
    - Smallint
    - Tinyint (0~255)
    - Bigint
  - 실수
    - Float(4,8)
    - Real
    - decimal(4-16)
      - numeric(4-16)
  - 문자
    - char
      - char(10) : String. 10자리. 2개만 입력 -> 8개 빈공간 남음
    - Varchar
      - 가변길이 char. Varchar(50)이 기본값.
        - 50이 맥시멈이지만 2글자만 써도 2개만 할당.
    - Text
      - Varchar의 응용. Varchar(max)와 동일

- 유니코드

  - Nchar
  - nvarchar
  - Ntext

- 날짜, 시간, 화폐

  - 날짜와 시간
    - datetime
    - smalldatetime
  - 화폐 (쓰지말것. 오류가 난다. decimal을 쓰자!)
    - money
    - smallmoney

- PK 설계

  - 유일 + NotNull
  - 후보 식별자가 없는 경우 임의의 식별자를 만들어 부여한다.(인조 식별자)
  - PK의 데이터 타입 결정

    - 레코드의 발생 가능한 최대 수를 예측
      - 한달에 12만개 판다.
        - int는 21억까지 되니 여유로움
        - (년도,월,seq번호) 를 PK로 잡으면 됨.
          - 년도를 19,20 과 같이 2자리로 잡으면 y2k 문제발생하지만 100년은 보장함.
    - 중학교, 고등학교의 pk
      - 500명이면 1~500 번호로 부여.
        - smallint
    - 크기가 정해져있는건 정하기 편하지만, 계속 데이터가 쌓여 크기가 계속 커지는 건 정하기 어렵다.

  - 고려사항
    - 발생 가능한 최대 레코드 수를 커버할 수 있는 데이터 타입을 선정
    - pk에는 어떤 의미도 부여하지 않는다. 담백하게 notnull & unique만 보장하면 된다.
    - pk 를 직접 쿼리문에 파라미터로 주면, 동시에 똑같은 pk 값을 요청하면 pk 중복으로 오류가 발생한다.
      - pk는 자동으로 증가하는 방식으로 설정해줘야한다.
      - pk 경쟁을 없애야한다.
    - 만약 pk 데이터타입이 char라면...?
      - 자동증가가 안됨.
      - 자릿수를 정렬해서 일목요연하게 해줌.
      - int를 써도 정렬되서 나온다.
      - 경쟁이 없게끔 int로 해서 자동증가를 적용하자.

# 관계

## 1 : M 관계

- 부모와 자식. 한쪽이 관계를 맺은 쪽의 여러 객체를 갖는 것을 의미하며, 가장 흔하게 나타나는 매우 일반적인 형태
  - 누구의 자식이냐? 부모의 pk 값이 자식 테이블의 컬럼에 나타남으로서 관계가 맺어진다. 부모가 없는 자식은 허용이 안된다. 이는 garbage data가 된다.
    - garbage data는 outer join하면 다 나온다. count가 된다. 그리고 join을 해봐야 garbage인지 알기 때문에 오류가 난다.
  - 부모 - 자식 - 손자 : 각각은 관계가 맺어져도 부모-손자의 관계는 아무 관계없다.
  - 부모의 pk값이 자식 테이블에게는 외래키(fk)가 된다. foreign key. 외부에 진짜 pk가 있다.(외부: 부모 테이블). fk는 중복으로 나타날 수 있다. fk는 부모 테이블에 반드시 pk로 존재해야한다.
  - 부모는 여러명의 자식을 낳을 수 있고 안낳을 수도 있다. 자식은 부모가 단 하나로 정해져있다.
  - 트리 구조는 전부 1:M
    - 디렉토리
  - 그림에서 오리발이 있는쪽이 M (자식), 없는쪽이 1 (부모)
  - ERD (entity relation diagram)
  - 자식이 있으면 부모를 삭제할 수 없다. 자식이 없어야 부모가 삭제 가능하다.
- pk를 튜플로 여러개 속성 이상으로 가져온다면, fk가 변경시 자식 테이블의 pk는 초기화된다. 1학년 1반 / 1학년 2반 / 2학년 3반 이 아니라
  2학년 1반으로, 3반 -> 1반으로 초기화

- 1 : M 재귀적 관계
  - 분류 코드
  - Directory
  - 내 안에 PK 와 FK 둘다 있다.

## M : N 관계 (비지니스 관계)

- 쌍방 입장에서 둘다 1 : M 일때를 말함
  - 사실 얘네는 둘이 관계가 없는데 무리하게 넣은 것.
  - 비지니스 로직이 있어야 둘이 관계를 갖게 됨.
  - 쌍방 PK가 중복이 발생하므로 관계형 데이터베이스로 안된다.
- 해결하기 위해 또 하나의 테이블이 필요
  - 동사 테이블
  - 날짜 컬럼이 꼭 필요함.
  - 학생이 과목을 언제 수강한다.
  - 잘 안 변경되는 학생, 과목 같은 테이블은 마스터라고 한다.
    - 마스터끼리 부자 지간인지 확인해야한다.
    - 아니라면 볼 것 없이 M : N 이라 하면 된다.
  - 동사 테이블도 pk가 있으므로 얘도 다른 테이블과 관계를 가질 수 있다.
  - 학생ID + 과목ID : 두가지를 합쳐 pk 로 할 수 있다.
    - A학생이 1번과목을 두번 수강신청 불가능
  - 버스는 좌석을 여러개 갖고 있다. (has 문장 성립 : 1 : M)
  - 고객이 상품을 여러개 갖고 있다. (사고 갖는다. 문장 성립x : M : N)
- 비지니스 로직에 따라 두번 수강신청 불가능 / 두번 구매 가능. 이런식으로 중복을 허용할지 말지 로직을 짜야한다.
  - 중복 허용해야하면 pk 독립적, 중복 허용하지 않아야 하면 튜플로 pk 구성
- 하나의 테이블은 하나의 객체를 모델링해야한다.
- Pk 가 너무 많아지면 얘를 부르기가 힘드므로 대체키를 설정해준다.
